# Javascript Interview Questions

### Basics

|Sl.No| Questions                                                                         |
|-----|-----------------------------------------------------------------------------------|
|    |[Explain Fetch API]()|
|    |[Explain Debounce Function]()|
|    |[Explain Throttling function]()|
|    |[In which scenarios you will use debounce and throttle?]()|
|    |[What are the new features of ES6?](#q-what-are-the-new-features-of-es6)|
|    |[List down all the data types in Javascript?](#q-list-down-all-the-data-types-in-javascript-)|
|    |[What is typeof operator?](#q-what-is-typeof-operator-)|
|    |[Explain instanceof operator?](#q-explain-instanceof-operator-)|
|    |[What is the difference between let and var ?](#q-what-is-the-difference-between-let-and-var-)|
|    |[Is JavaScript a compiled or interpreted language?](#q-is-javascript-a-compiled-or-interpreted-language)|
|    |[What is the difference between == and === ?](#q-what-is-the-difference-between--and--)|
| N  |[Axios API Call]()|
|    |[What is currying function ?]()|
|    |[How do you write sum(1)(2)(3)(4)(5).......n args]()|
| N  |[Partial Application]()|
| N  |[Sets]()|
| N  |[Map]()|
| N  |[Service and WebWorkers]()|
| N  |[What is Temporal Deadzone]()|

### Objects

|Sl.No| Questions                                                                         |
|-----|-----------------------------------------------------------------------------------|
|    |[In how many ways you can create an object in Javascript?](#q-in-how-many-ways-you-can-create-an-object-in-javascript-)|
|    |[How to check whether a key exist in a JavaScript object or not?](#q-how-to-check-whether-a-key-exist-in-a-javascript-object-or-not-)|
|    |[How does Object.create method works in Javascript?](#q-how-does-objectcreate-method-works-in-javascript-)|
|    |[How does Object.assign method works in Javascript?](#q-how-does-objectassign-method-works-in-javascript-)|
|    |[Write a function that will do shallow cloning of a object?](#q-write-a-function-that-will-do-shallow-cloning-of-a-object-)|
|    |[Write a function that will do deep cloning of a object?](#q-write-a-function-that-will-do-deep-cloning-of-a-object-)|
|    |[How do you prevent the modifications of a object in Javascript?](#q-how-do-you-prevent-the-modifications-of-a-object-in-javascript-)|
|    |[How do you merge two objects dynamically?](#q-how-do-you-merge-two-objects-dynamically-)|
|    |[Explain Object Prototype in details?](#q-explain-object-prototype-in-details)|
|    |[How do you achieve inheritance using prototype?](#q-how-do-you-achieve-inheritance-using-prototype)|
|    |[How do you achieve inheritance using ES6 classes?](#q-how-do-you-achieve-inheritance-using-es6-classes)|


### Arrays

|Sl.No| Questions                                                                         |
|-----|-----------------------------------------------------------------------------------|
|    |[Explain Arrays in details with all methods and examples?](#q-explain-arrays-in-details-with-all-methods-and-examples)|
|    |[How many ways to empty an array ?](#q-how-many-ways-to-empty-an-array-)|
|    |[How do you check if an object is an array or not?](#q-how-do-you-check-if-an-object-is-an-array-or-not)|

### Functions

|Sl.No| Questions                                                                         |
|-----|-----------------------------------------------------------------------------------|
|    |[What are first class functions or functions as first class citizens?](#q-what-are-first-class-functions-or-functions-as-first-class-citizens)|
|    |[What is named function expression?](#q-what-are-named-function-expression-)|
|    |[What is the difference between function statement, function declaration and function expression?](#q-what-is-the-difference-between-function-statement-function-declaration-and-function-expression)|
|    |[What are callback functions?](#q-what-are-callback-functions)|
| N  |[What is callback hell]()|
| N  |[What are self memorizing functions?](#q-what-are-self-memorizing-functions)|
|    |[What is pure function ?](#q-what-is-pure-function-)|
|    |[What is Hoisting, how does variables and function declarations works behind the scene.](#q-what-is-hoisting-how-does-variables-and-function-declarations-works-behind-the-scene)|
|    |[What is IIFE (Immediately Invoked Functional Expression?)](#q-what-is-iife-immediately-invoked-functional-expression)|
|    |[What are implicit function parameters?](#q-what-are-implicit-function-parameters)|
|    |[What is this parameter and how it works in all function calls?](#q-what-is-this-parameter-and-how-it-works-in-all-function-calls)|
|    |[What if a constructor is returning a value?](#q-what-if-a-constructor-is-returning-a-value)|
|    |[What is call and apply?](#q-what-is-call-and-apply-method)|
|    |[How does bind works in Javascript?](#q-how-does-bind-works-in-javascript)|
| N  |[How does arrow function works wrt this?]()|
| N  |[What is closure?]()|
| N  |[How do you create private variables with the help of closure?]()|
| N  |[How do you track code execution with execution contexts?]()|
| N  |[How do you keep track of identifiers with lexical environment?]()|
|    |[What is promise in javascript?](#q-what-is-promise-in-javascript)|
| N  |[Describe promise with real life problem of API Call]()|
|    |[What is promise chaining?](#q-what-is-promise-chaining)|
| N  |[What is Promise.all?]()|
| N  |[What is Promise.race?]()|
| N  |[What is the difference between callback and promise?]()|
| N  |[What is difference between private variable, public variable and static variable? How we achieve this in JS?](#)|

### Events

|Sl.No| Questions                                                                         |
|-----|-----------------------------------------------------------------------------------|
|    |[Define Event Capturing and Bubbling](#q-define-event-capturing-and-bubbling)|
|    |[What is Event Delegation](#q-what-is-event-delegation-)|
|    |[What is Event Propagation and how do you stop propagation ?](#q-what-is-event-propagation-and-how-do-you-stop-propagation-)|
|    |[What is event.preventDefault ?](#q-what-is-eventpreventdefault-)|
| N  |[Explain Event Queue](#q-explain-event-queue-)|


### New Features of ES6

|Sl.No| Questions                                                                         |
|-----|-----------------------------------------------------------------------------------|
| N  |[Default Parameters]()|
| N  |[Rest Parameters]()|
| N  |[Spread operator]()|
| N  |[Async / Await]()|
| N  |[Template Literal]()|
| N  |[Desctructing Assignment]()|
| N  |[Object.assign and Object.is]()|
|    |[Generator functions](#generator-functions)|
| N  |[Classes]()|

### What is Shadow DOM ?



### What are Web Workers ?

JavaScript is a single threaded language which means you can not run multiple javascript script files at a time (in case of browsers). Suppose, you have a heavy calculations that has to be performed and it is time consuming so by default after some time your browser stops responding and you will get get Not Responding alert.

<p align="center">
	<img src="https://user-images.githubusercontent.com/50094184/146675936-27b68874-bcc9-4353-a428-06a34c614c51.png" width="60%" />
</p>

Now, if you say you are making api call and its multi threading. No, its not its `NON BLOCKING` operation.

**`Web Worker`** provides mechanism to run a separate script in background for your web applicaiton where you can perform the complex calculations without disturbing the UI. 

Communication between the page and the worker is made using simple mechanism. They can send message to each other using `postMessage()` method and they receive the messages they send using `onmessage()` callback function.

Let's take a simple example where we will delegate the work to add two numbers to worker and it will return us the result.

**`main.js`**
```js
const submitForm = document.querySelector("#submitForm");

submitForm.addEventListener("click", () => {
  if (window.Worker) {
    const myWorker = new Worker("worker.js");

    const message = {
      addVals: {
        num1: 10,
        num2: 15,
      },
    };

    myWorker.postMessage(message);

    myWorker.onmessage = (e) => {
      console.log("Result is: ", e.data.result);
    };
  }
});
```

**`worker.js`**
```js
this.onmessage = function (e) {
  if (e.data.addVals !== undefined) {
    const { num1, num2 } = e.data.addVals;
    const sum = num1 + num2;

    this.postMessage({ result: sum });
  }
};
```

### What is service worker and caching ?

- Service worker is a javascript file that gets registered with the browser
- Stays registered with the browser even when offline
- Can load content even with no connection

<p align="center">
	<img src="https://user-images.githubusercontent.com/50094184/146739680-54a14c52-8547-483b-92a3-19c066c72dff.png" width="60%" />
</p>

<p align="center">
	<img src="https://user-images.githubusercontent.com/50094184/146740079-8f76a103-49c6-41dd-8211-132b6cd0ee5d.png" width="60%" />
</p>

**Some Facts About Service Workers**
- They can not directly access the DOM, instead they communicate using postMessage interface.
- Programmable network proxy: They handle how network request from your page is handled.
- Terminated when not in use
- Make use of promises
- Requires HTTPS unless on localhost
- Supported by all major browsers

**Use Cases**
- Caching Assets(media: images, icons) and API Calls: Offline viewing of the web pages
- Push Notifications
- Used in Progressive Web Apps (PWA)

<p align="center">
	<img src="https://user-images.githubusercontent.com/50094184/146742511-ede51291-f9db-4cf1-9d3c-15b2d7275710.png" width="60%" />
</p>


### What are all the HTTP Methods ?

- GET
- HEAD
- POST
- PUT
- DELETE
- PATCH

**`GET`**

GET method is used to retrieve the data from the server at the specified resource. It should not send any data with the request. It is better to avoid sending payload in `GET` requests. 

Example, you have an API with /users. Making a `GET` request to that endpoint should return the list of all the users. It returns the data in the XML or JSON format and an HTTP response code of `200 (OK)`.

Status Codes:

**Success:** 
`200 (OK)`

**Failure:** 
`404 (NOT FOUND)`
`400 (BAD REQUEST)`

Since, GET is only requesting data from the server and not modifying any resource. Its considered a `safe, idempotent and cacheable method`.

- `GET` is **`safe`** which means you can not modify the resource at the server using this request.
- `GET` is **`idempotent`** which means that making multiple identical requests ends up having the same result.

**Examples:**
- GET http://www.example.com/customers/12345
- GET http://www.example.com/customers/12345/orders
- GET http://www.example.com/buckets/sample


**`POST`**
`POST` method is used to create new resource. It is used to create subordinate (lower in rank) resource. Subordinate means which are subordinate to other(parent) resource. 

On successful creation, returns HTTP status code `201 Created`, returning a Location header with a link to the newly created resource.

POST is `neither safe nor idempotent`.

- `POST` is **`not idempotent`** which means that making multiple identical requests ends up having multiple ids with same information. Hence, its not safe. 

### What is the difference between PUT and PATCH ?

Both PUT and PATCH are used to update the resource at the server. But it differs how we are passing the data:

```js
## /users/1

{
    "username": "skwee357",
    "email": "skwee357@domain.com"
}
```

Using PUT, you have to pass the complete entity.
```js
PUT /users/1
{
    "username": "skwee357",
    "email": "skwee357@gmail.com"       // new email address
}
```

Using PATCH, you can pass only the modified fields.
```js
PATCH /users/1
{
    "email": "skwee357@gmail.com"       // new email address
}
```

### What are all the HTTP Response status codes?

HTTP Response Status code indicates whether a specified HTTP Request has been successfully completed or not. Responses are grouped into five categories:

1. Informational responses (100 - 199)
2. Successful responses (200 - 299)
3. Redirection responses (300 - 399)
4. Client error responses (400 - 499)
5. Server error responses (500 - 599)

Below are some of the common response status codes:

**Informational responses:**
- `102 Processing`: This code indicates that server has received and processing the request, but no response is available yet.

**Successful responses:**
- `200 OK`: The request succeeded. The result "success" depends upon the HTTP method:
	- `GET`: The resource has been fetched and transmitted in the message body
	- `HEAD`: This represents headers are included in the response without message body
	- `PUT` or `POST`: This repsents the result of the action provided by server in the message body (eg. id)

- `201 Created`: The request succeeded, and new resource was created as a result. This is the response status code sent from server after `POST` or `PUT` request.

**Redirection responses:**
- `301 Moved Permanently`: The URL of the requested resource has been moved permanently. The new URL is provided in the response.
- `307 Temporary Redirect`: 
- `308 Permanent Redirect`: This means that the resource is now permanently located at another URI, specified by the `Location:` HTTP Reponse header.

**Client error responses:**
- `400 Bad Request`: The server could not understand the request due to invalid syntax.
- `401 Unauthorized`: Here, the client is not authenticated. So client need to authenticate first to get the resource from the server. 
- `403 Forbidden`: The client does not have access rights to the resource i.e. its unauthorized, so the server is refusing to give the requested resource. Here, Client Identity is known to the server. Here, user is authenticated but does not have rights to access the resource.
- `404 Not Found`: The server can not find the requested resource. 
- `405 Method Not Allowed`: In this case, suppose you requested for DELETE operation on the resource but that action only supports GET operation from the server. So, method name is incorrecly passed so it will return Method Not Allowed.

**Server error responses:**
- `500 Internal Server Error`: The server has encountered a situation it does not know how to handle.
- `503 Service Unavailable`: The server is not ready to handle the request. Common causes: server is down due to maintenance or overloaded.
- `504 Gateway Timeout`: The error response is given when the server is acting as a gateway and cannot get a response in time.

### Q. Explain Fetch API

`Fetch API` provides an interface for fetching resources (including across the network).

For making request and fetching a resource, use `fetch()` method. It is a part of `windows` object. Hence, can use used as `window.fetch()`

The `fetch()` method takes one mandatory argument, the path of the resouce you want to fetch. It returns a `Promise` which is fulfilled once the response is available.

The promise resolves to the `Response` object representing the response to your request. The promise `does not` reject on HTTP errors - it only rejects on network errors. You must use `then` handlers to check for HTTP errors.

A **`fetch()`** promise only rejects when a network error is encountered (which is usually when there is a permission issue). A **`fetch()`** promise does not reject on HTTP errors (404 error code etc). Instead, a `then()` handler must check the `Response.ok` and/or `Response.status` properties.

```js
const fetchResponsePromise = fetch(resource, [options]);
```
**GET Request (Using async-await)**
```js
async function getDataUsingAsyncAwait() {
  const URL = "https://api.github.com/users/harmansingha/repos";
  const response = await fetch(URL, { method: 'GET' });
  
  try{
    if(!response.ok){
      throw new Error(response.status);
    }else{
      const data = await response.json();
      console.log("Data: ", data);
    }
  }catch(error){
    console.error(error)
  }
  
}

getDataUsingAsyncAwait();
```

**GET Request (Using Promises and then)**
```js
function getData() {
  const URL = "https://api.github.com/users/hamansingha/repos";

  fetch(URL, { method: "GET" })
    .then((response) => {
      if (!response.ok) {
        console.log(response)
        throw new Error(response.status);
      }

      return response.json();
    })
    .then((data) => {
      console.log(console.log("Data: ", data));
    })
    .catch((error) => {
      console.error(error);
    });
}

getData();
```


### Q. Explain Debounce Function ?

```js
//Debouncing
const submitForm = document.querySelector('#submitForm');


function debounce(fn, wait){
    let timer;
    return function () {
        clearTimeout(timer);
        timer = setTimeout(() => {
            fn(arguments[0]);
        }, wait);
    }

}

function performApiCall(name) {
    console.log('Perform Api Call...', name);
}

const betterDebouncFunction = debounce(performApiCall('Hamran'), 1000);

submitForm.addEventListener('click', betterDebouncFunction);
```

### Q. Explain Throttling function ?

```js
//Throttling
// ' ' ' ' ' ' 500ms ' ' ' ' ' ' ' ' ' '
const submitForm = document.querySelector('#submitForm');

const throttle = (fn, wait) => {
    let shouldRun = true;
    return function () {
        console.log("shouldRun: ", shouldRun)
        if(shouldRun){
            fn();
            shouldRun = false;

            setTimeout(() => {
                shouldRun = true;
            }, wait);
        }
    }
}

function performApiCall() {
    console.log("Perform API Call");
}

const betterFunction = throttle(performApiCall, 5000);

submitForm.addEventListener('click', betterFunction);
```

### Q. What is currying function ?

Currying is when you break down a function that takes multiple arguments into a series of function that each take only one argument. Here's example:

**Normal Function**:
```js
function calculateVolume(length, width, height) {
  return length * width * height;
}

const result = calculateVolume(10, 2, 3);
console.log("Result: ", result);
```

**With Currying**
```js
//Curried Function
function calculateVolume(length) {
  return function (width) {
    return function (height) {
      return length * width * height;
    };
  };
}

//Usage No 1
const volumeWithLength = calculateVolume(10);
const volumeWithLengthWidth = volumeWithLength(2);
const result = volumeWithLengthWidth(3);
console.log(result);

//Usage No 2
const res = calculateVolume(10)(2)(3);
console.log(res)
```

### Q. How do you write sum(1)(2)(3)(4)(5).......n args

```js
const sum = function (num1) {
    return function (num2) {
        if(num2 !== undefined){
            return sum(num1 + num2);
        }
        else{
            return num1;
        }
    }
}

console.log(sum(1)(2)(4)(5)());
```

### Q. What are the new features of ES6?

1. Default Parameters
2. let and const
3. Arrow functions
4. Template literals
5. Destructuring assignment
6. Spread and Rest Operator
7. Object.assign and Object.is
8. Classes

### Q. List down all the data types in Javascript ?

There are eight basic data types in JavaScript.

|Data Types	  | Description	                         |Example                     |
|-------------|--------------------------------------|----------------------------|
|String	      |Represents textual data	             |let str = 'Hi', let str2 = "Hello", let str3 = \`Hello World\`|
|Number	      |An integer or a floating-point number |let num = 3, let num2 = 3.234, let num3 = 3e-2 |
|BigInt	      |An integer with arbitrary precision	 |let num = 900719925124740999n, let num = 1n    |
|Boolean	    |Any of two values: true or false	     |let flag = true             |
|undefined	  |A data type whose variable is not initialized	|let a;             |
|null	        |Denotes a null value	                 |let a = null;               |
|Object	      |key-value pairs of collection of data	|let student = { };         |

**String**

`String` is used to store text. In JavaScript, strings are surrounded by quotes:

* Single quotes: 'Hello'
* Double quotes: "Hello"
* Backticks: \`Hello\`

Example:

```js
//Strings 
const firstName = 'John';
const lastName = "K";
const result = `The names are ${firstName} and ${lastName}`;
```

**Number**

Number represents integer and floating numbers (decimals and exponentials). A number type can also be `+Infinity`, `-Infinity`, and `NaN` (not a number).

```js
const number1 = 3;
const number2 = 3.433;
const number3 = 3e5 // 3 * 10^5

const number1 = 3/0;
console.log(number1); // Infinity

const number2 = -3/0;
console.log(number2); // -Infinity

// strings can't be divided by numbers
const number3 = "abc"/3; 
console.log(number3);  // NaN
```

**BigInt**

A BigInt number is created by appending `n` to the end of an integer.

```js
// BigInt value
const num1 = 900719925124740998n;
const num2 = 900719925124740998n;
const num3 = 10;


// Adding two big integers
const result1 = num1 + num2;
console.log(result1); // "1801439850249481996n"


// Error! BitInt and number cannot be added
const result2 = num1 + num2 + num3; 
console.log(result2);  // Uncaught TypeError: Cannot mix BigInt and other types
```

**Boolean**

This data type represents logical entities. Boolean represents one of two values: `true` or `false`. 

```js
const dataChecked = true;
const valueCounted = false;
```

**undefined**

The undefined data type represents value that is not assigned. If a variable is declared but the value is not assigned, then the value of that variable will be undefined. 

```js
let name;
console.log(name); // undefined

let name = undefined;
console.log(name); // undefined
```

**null**

In JavaScript, `null` is a special value that represents empty or unknown value.

```js
const number = null;
```

**Object**

An object is a complex data type that allows us to store collections of data. 

```js
const employee = {
    firstName: 'John',
    lastName: 'K',
    email: 'john.k@gmail.com'
};
```

### Q. What is typeof operator ?

In JavaScript, the **`typeof`** operator returns the data type of its operand in the form of a string. The operand can be any object, function, or variable.

**Example: - 01**

```js
typeof undeclaredVariable; // "undefined"

var a;
typeof a; // "undefined"

a = "Hello World";
typeof a; // "string"

a = 42;
typeof a; // "number"

a = 3.1415
typeof a; // "number"

a = true;
typeof a; // "boolean"

a = null;
typeof a; // "object"

a = undefined;
typeof a; // "undefined"

a = { b: "c" };
typeof a; // "object"
```

```js
// Numbers
typeof 37 === 'number';
typeof 3.14 === 'number';
typeof(42) === 'number';
typeof NaN === 'number';       
typeof Number('1') === 'number';  // Number tries to parse things into numbers
typeof Number('Hi') === 'number'; // including values that cannot be type coerced to a number Number('Hi') will return NaN so type of NaN is number

typeof 42n === 'bigint';

// Strings
typeof '' === 'string';
typeof 'Hello' === 'string';
typeof `template literal` === 'string';
typeof '1' === 'string';  // note that a number within a string is still typeof string
typeof (typeof 1) === 'string';  // typeof always returns a string
typeof String(1) === 'string';  // String converts anything into a string, safer than toString

// Booleans
typeof true === 'boolean';
typeof false === 'boolean';
typeof Boolean(1) === 'boolean'; // Boolean() will convert values based on if they're truthy or falsy

// Undefined
typeof undefined === 'undefined';
typeof declaredButUndefinedVariable === 'undefined';
typeof undeclaredVariable === 'undefined';

// Objects
typeof {a: 1} === 'object';

// use Array.isArray or Object.prototype.toString.call
// to differentiate regular objects from arrays
typeof [1, 2, 4] === 'object';

typeof new Date() === 'object';
typeof /regex/ === 'object'; 

// The following are confusing. 
typeof new Boolean(true) === 'object';
typeof new Number(1) === 'object';
typeof new String('abc') === 'object';

// Functions
typeof function() {} === 'function';
typeof class C {} === 'function';
typeof Math.sin === 'function';
```

### Q. Explain instanceof operator ?

The `instanceof` operator tests the presence of `constructor.prototype` in `object's` prototype chain.

```js
object instanceof constructor
```

```js
// defining constructors
function C() {}
function D() {}

let o = new C()

// true, because: Object.getPrototypeOf(o) === C.prototype
o instanceof C

// false, because D.prototype is nowhere in o's prototype chain
o instanceof D

o instanceof Object           // true
```

```js
let literalString = 'This is a literal string';
let stringObject  = new String('String created with constructor');

literalString instanceof String;  // false, string literal is not a String
stringObject  instanceof String;  // true

literalString instanceof Object;  // false, string literal is not an Object
stringObject  instanceof Object;  // true

stringObject  instanceof Date;    // false
```

```js
let myDate = new Date();

myDate instanceof Date;      // true
myDate instanceof Object;    // true
myDate instanceof String;    // false
```


### Q. What is the difference between let and var ?

1. `Redeclaration`: Can redeclare var but let can't be.
2. `Hoisting`: Var can be hoisted to the top of the scope whereas let can't be hoisted.
3. `Scope`: Scope of var is function level whereas scope of let is block level (for, if)

### Q. Is JavaScript a compiled or interpreted language?

JavaScript is an interpreted language, not a compiled language. An interpreter in the browser reads over the JavaScript code, interprets each line, and runs it. Nowadays  modern browsers use a technology known as Just-In-Time (JIT) compilation, which compiles JavaScript to executable bytecode just as it is about to run.

### Q. What is the difference between == and === ?

**==**: is used to compare two variables values without comparing the data type
**===**: is preferred to compare two variables data types first and then its value comparison.

## Objects

### Q. In how many ways you can create an object in Javascript ?

There are 4 ways to create object in javascript:

1. Object literals
2. Creating object with a constructor function
3. Object.create
4. ES6 Classes

**Object Literals**

Literals are smaller and simpler ways to define objects.We simple define the property and values inside curly braces as shown below:

```js
//creating js objects with object literal
const car = {
    name : 'GT',
    maker : 'BMW',
    engine : '1998cc'
};
//property accessor
console.log(car.name); //dot notation
console.log(car['maker']); //bracket notation
```

**Creating object with a constructor function:**
Constructor is nothing but a function and with help of new keyword, constructor function allows to create multiple objects of same flavor as shown below:

```js
//simple function
function Vehicle(name,maker,engine){
    this.name = name;
    this.maker = maker;
    this.engine = engine;
}
//new keyword to create an object
let car  = new Vehicle('GT','BMW','1998cc');
//property accessors
console.log(car.name);
console.log(car.maker);
console.log(car['engine']);
```

**Creating object with Object.create() method**

The Object.create() method creates a new object, using an existing object as the prototype of the newly created object.

```js
const coder = {
    isStudying : false,
    printIntroduction : function(){
        console.log(`My name is ${this.name}. Am I studying?: ${this.isStudying}`);
    }
};
const me = Object.create(coder);
me.name = 'Mukul';
me.isStudying = true;
me.printIntroduction();
```

**Using es6 classes:**

ES6 supports class concept like any other Statically typed or object oriented language. So, object can be created out of a class in javascript as well as shown below:

```js
//using es6 classes
class Vehicle {
  constructor(name, maker, engine) {
    this.name = name;
    this.maker =  maker;
    this.engine = engine;
  }
}
  
let car1 = new Vehicle('GT', 'BMW', '1998cc');
  
console.log(car1.name);  //GT
```

### Q. How to check whether a key exist in a JavaScript object or not ?

Let say we have person object with property name and age

```js
var person = {
	name: 'Nishant',
	age: 24
}
```

**Method 1:** We can use `in` operator on objet to check own property or inherited property.

```js
console.log('name' in person); // checking own property print true 
console.log('salary' in person); // checking undefined property print false
```

`in` operator also look into `inherited` property if it doesn't find property defined as own property. For instance If I check existence of toString property as we know that we haven't declared this property on person object so in operator look into there base property.

```js
console.log('toString' in person); // Will print true
```

**Method 2:** hasOwnProperty
If we want to test property of object instance not inherited properties then we will use hasOwnProperty method of object instance.

```js
console.log(person.hasOwnProperty('toString')); // print false
console.log(person.hasOwnProperty('name')); // print true
console.log(person.hasOwnProperty('salary')); // print false
```

### Q. How do you iterate through the object keys and values ?

```js
const user = {
  name: "Harman",
  email: "harmanlive786@outlook.com",
};

// How many ways to loop through object
//1. Object.entries & for..of loop

for (const [key, value] of Object.entries(user)) {
  console.log("Key: ", key, " Value: ", value);
}

//2. Object.entries and forEach loop

Object.entries(user).forEach(([key, value]) => {
  console.log("Key: ", key, " Value: ", value);
});

//3. Get Only the values

Object.values(user).forEach((val) => console.log(val));

//4. Loop through the keys

Object.keys(user).forEach((val) => console.log(val));
```


### Q. How does Object.create method works in Javascript ?

**Syntax:**

The `Object.create()` method creates a new object, using an existing object as the prototype of the newly created object.

```js
Object.create(proto)
Object.create(proto, propertiesObject)
```

```js
const person = {
  isHuman: false,
  printIntroduction: function() {
    console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);
  }
};

const me = Object.create(person);

me.name = 'Matthew'; // "name" is a property set on "me", but not on "person"
me.isHuman = true; // inherited properties can not be overwritten rather it creates a new property in me object

me.printIntroduction();
// expected output: "My name is Matthew. Am I human? true"
```

### Q. How does Object.assign method works in Javascript ?

The `Object.assign()` method copies all `enumerable own properties` from one or more source objects to a target object. It returns the modified target object.

```js
Object.assign(target, ...sources)
```

- Properties in the target object are overwritten by properties in the sources if they have the same key.
- The Object.assign() method only copies enumerable and own properties from a source object to a target object.
- It just does shallow copy of the object, if there is any referenced type property it will be taken as reference rather than new copy of it.

```js
const target = { a: 1, b: 2 };
const source = { b: 4, c: 5 };

const returnedTarget = Object.assign(target, source);

console.log(target);
// expected output: Object { a: 1, b: 4, c: 5 }

console.log(returnedTarget);
// expected output: Object { a: 1, b: 4, c: 5 }
```

```js
Cloning an object

const obj = { a: 1 };
const copy = Object.assign({}, obj);
console.log(copy); // { a: 1 }

```

### Q. Write a function that will do shallow cloning of a object ?

```js
const employee = {
  name: "Harman",
  rollNo: 44,
  class: "7th",
  subjects: {
    english: "English is my fav subject",
    hindi: "I am fine with that",
  },
};
```

**Method 1: Using Object.assign**

```js
//Creates new object but does not create deep copy of the referenced objects
const newEmployee = {};
Object.assign(newEmployee, employee);

newEmployee.name = 'Harry'; 
newEmployee.subjects.english = 'Changed english'; //This will change the original object (so its just shallow clone)
```

**Method 2: Using Spread Operator**

```js
const newEmployee = { ...employee };
newEmployee.name = "Harry";
newEmployee.subjects.english = "Changed english"; //This also changes the original object
```

### Q. Write a function that will do deep cloning of a object ?

```js
const employee = {
  name: "Harman",
  rollNo: 44,
  class: "7th",
  subjects: {
    english: "English is my fav subject",
    hindi: "I am fine with that",
  },
};
```

**Method 1: Using JSON.stringify and JSON.parse**

Use this when not sure about the hierarchy of the object how deep it is.

```js
const newEmployee = JSON.parse(JSON.stringify(employee)); // This will create a new object as deep cloned
newEmployee.name = 'Harry';
newEmployee.subjects.english = 'Changed english';
```

**Method 2: Using Custom function**

```js
function deepClone(object){
	var newObject = {};
	for(var key in object){
		if(typeof object[key] === 'object'  && object[key] !== null ){
		 newObject[key] = deepClone(object[key]);
		}else{
		 newObject[key] = object[key];
		}
	}
	return newObject;
}
```

**Method 3: Using spread operator**

Use this when sure about the depth of the object

```js
const newEmployee = { ...employee, 
			subjects: { ...employee.subjects } 
		    };
newEmployee.name = "Harry";
newEmployee.subjects.english = "Changed english";
```

### Q. How do you prevent the modifications of a object in Javascript ?

ECMAScript 5 introduce several methods to prevent modification of object which lock down object to ensure that no one, accidentally or otherwise, change functionality of Object.

There are three levels of preventing modification:

**1. Prevent extensions**

No new properties or methods can be added to the object, but one can change the existing properties and method.

```js
var employee = {
	name: "Nishant"
};

// lock the object 
Object.preventExtensions(employee);

// Now try to change the employee object property name
employee.name = "John"; // work fine 

//Now try to add some new property to the object
employee.age = 24; // fails silently unless it's inside the strict mode
```

**2. Seal**

It is same as prevent extension, in addition to this also prevent existing properties and methods from being deleted.

To seal an object, we use `Object.seal()` method. you can check whether an object is sealed or not using `Object.isSealed()`;

When an object is sealed, its existing properties and methods can't be removed. Sealed object are also non-extensible.

```js
var employee = {
	name: "Nishant"
};

// Seal the object 
Object.seal(employee);

console.log(Object.isExtensible(employee)); // false
console.log(Object.isSealed(employee)); // true

delete employee.name // fails silently unless it's in strict mode

// Trying to add new property will give an error
employee.age = 30; // fails silently unless in strict mode
```

**3. Freeze**

Same as seal, In addition to this prevent existing properties methods from being modified (All properties and methods are read only).

To freeze an object, use `Object.freeze()` method. We can also determine whether an object is frozen using `Object.isFrozen();`

```js
var employee = {
	name: "Nishant"
};

//Freeze the object
Object.freeze(employee); 

console.log(Object.isExtensible(employee)); // false
console.log(Object.isSealed(employee));     // true
console.log(Object.isFrozen(employee));     // true


employee.name = "xyz"; // fails silently unless in strict mode
employee.age = 30;     // fails silently unless in strict mode
delete employee.name   // fails silently unless it's in strict mode
```

Frozen objects are considered both non-extensible and sealed.

### Q. How do you merge two objects dynamically ?

There are multiple ways to merge objects:

**Method 1:** `Using Object.assign`

```js
const o1 = { a: 1 };
const o2 = { b: 2 };
const o3 = { c: 3 };

const obj = Object.assign(o1, o2, o3);
console.log(obj); // { a: 1, b: 2, c: 3 }
console.log(o1);  // { a: 1, b: 2, c: 3 }, target object itself is changed.
```

`Merging Object with same properties`

```js
const o1 = { a: 1, b: 1, c: 1 };
const o2 = { b: 2, c: 2 };
const o3 = { c: 3 };

const obj = Object.assign({}, o1, o2, o3);
console.log(obj); // { a: 1, b: 2, c: 3 }
```

**Method 2:** `Using Spread Operator`

```js
const o1 = { a: 1 };
const o2 = { b: 2 };

const newObj = {...o1, ...o2};
```

Both of these methods does shallow merge only!

---

### Q. Explain Object prototype in details?

Every object can have a `reference` to its prototype, an object to which the search for a particular property can be delegated to, if object doesn't have that property.

When developing software we strive not to reinvent the wheel so we want to reuse as much code as possible. One form of code reuse that also helps organize our programs is inheritance, extending the featues of one object into another. In javascript, `inheritance` is implemented with `prototype`.

```js
const yoshi = { skull: true };
const hattori = { sneak: true };
const kuma = { creep: true };

console.log('skull' in yoshi); //true
console.log('sneak' in yoshi); //false
console.log('creep' in yoshi); //false

Object.setPrototypeOf(yoshi, hattori); //Sets prototype of hattori to yoshi, this allows yoshi able to access hattori props
console.log('sneak' in yoshi); //true

Object.setPrototypeOf(hattori, kuma); //Sets prototype of kuma to hattori, this allows hattori able to access kuma props and yoshi able to access kuma through hattori

console.log('creep' in yoshi); //true
```

`in` operator helps in accessing inherited properties here. 

`Object.setPrototypeOf` in-built method takes two object's arguments and sets the second object as the prototype of the first.

In Javascript, the object's prototype property is an internal property that's not directly accessible (so we mark it with [[prototype]]).

It is important to emhasize that every object can have a prototype and an object's prototype can also have a prototype, and so on, forming a prototype chain. The search delegation for a particular property occurs up the whole chain, and it stops only when there are no more prototypes to explore.

<p align="center">
	<img src="https://user-images.githubusercontent.com/50094184/137079021-174c1f7f-9676-4d9e-8b30-01a5a021dbc0.png" width="40%" />
</p>


**`Constructor Functions and Prototype`**

```js
function Ninja(game) {                        // Defined a constructor function
  this.game = game;
}

Ninja.prototype.gameType = 'Athlete';
Ninja.prototype.swingSword = function() {     // Every function has a built-in prototype object
  return true;                                // that we can freely modify
}

const n1 = new Ninja('Hockey');
console.log(n1);
```

<p align="center">
	<img src="https://user-images.githubusercontent.com/50094184/137080860-9ee32fa4-d49b-40b4-a10f-826092766ce9.png" width="40%" />
</p>

When a function is created, it immediately gets a new object assigned to its `prototype object`, an object that we can extend just like any other object.

Imp: 
- The prototype object initially has only one property, `constructor`, that references back to the function.
- When we use a function as a constructor, the prototype of the newly constructed object is set to the object referenced by the constructor function's prototype.

<p align="center">
	<img src="https://user-images.githubusercontent.com/50094184/137084112-7ddbdb85-0ac0-43f0-9758-2618639eb858.png" width="50%" />
</p>


**`Side effects of the dynamic nature of Javascript`**

Javascript is a dynamic language in which properties can be easily added, removed, and modified at will and the same thing holds with prototype as well, both function prototype and object prototype.

```js
function Ninja() {
  this.isPlayer = true;
}

Ninja.prototype.getIsPlayer = function() {
  return this.isPlayer;
}

const n1 = new Ninja();
console.log(n1.getIsPlayer());  // true

//Overwriting the prototype object itself to another object
Ninja.prototype = {
  testFn: function() {
    return false;
  }
}

const n2 = new Ninja();
console.log(n2.testFn());
console.log(n2.getIsPlayer());      //getIsPlayer is not a function
console.log(n1.getIsPlayer());      //true
console.log(n1.testFn())            //testFn is not a function
```

**Note:**

- When an object is created, object will retain the prototype properties which were present in the function constructor prototype at that time. If there is any changes to the prototype after object creation, it will not hamper the prototype of the earlier created objects.

### Q. How do you achieve inheritance using prototype?

Inheritance is a form of reuse in which new objects will have access to properties of existing objects. This avoids us in redeclaring the properties in the new objects rather it can reuse the existing props. 

**`Without inheritance using prototype`**:

```js
function Person() {
  this.name = "Harman";
}

Person.prototype.getUserDetails = function () {};

function User() {}
User.prototype = {
  getUserDetails: Person.prototype.getUserDetails,
};

const u1 = new User();

console.log(u1 instanceof User);  // true
console.log(u1 instanceof Person); // false, it can not maintain the prtotype chain here, so its not inheritance
console.log(u1 instanceof Object); // true
```

**`With inheritance using prototype`**:

What we really need to achive is the prototype chaining so that User can be a Person, and a Person can be Object.

User -> Person -> Object

```js
SubClass.prototype = new SuperClass();
```

```js
function Person() {
  this.name = "Harman";
}

Person.prototype.getUserDetails = function () {};

function User() {}
User.prototype = new Person();

const u1 = new User();

console.log(u1 instanceof User);  // true
console.log(u1 instanceof Person); // true
console.log(u1 instanceof Object); // true

console.log(u1.constructor);  // Person constructor (This is a problem here)
```

**`Note:`**

The above assignment of `User.prototype = new Person();` will overrite the constuctor property of User. Because we overwitten the complete prototype of User to the Person object. So, if we access User.constructor then it will point to Person.constuctor which is not a ideal case, it should be User.constructor. This can be solved by below code:

```js
Person.prototype.getUserDetails = function () {};

function User() {}
User.prototype = new Person();

Object.defineProperty(User.prototype, 'constructor', {
  enumerable: false,
  value: User,
  writable: true
});

const u1 = new User();

console.log(u1 instanceof User);  // true
console.log(u1 instanceof Person); // true
console.log(u1 instanceof Object); // true

console.log(u1.constructor);  // User constructor
```

**`Note:`**

Make sure not to use `SubClass.prototype = SuperClass.prototype` this will assign the reference of the SuperClass prototype to the SubClass prototype. Hence, any changes to the SubClass prototype will also change to the SuperClass, so that might create problems at the runtime.


### Q. How do you achieve inheritance using ES6 classes?

```js
class Person {
  constructor(name) {
    this.name = name;
  }

  getName() {
    return this.name;
  }
}

class User extends Person {
  constructor(name, salary) {
    super(name);
    this.salary = salary;
  }

  getUserDetails() {
    return {
      salary: this.salary,
      name: this.getName(),
    };
  }
}

const u1 = new User('Harman', 123);

console.log(u1 instanceof User);  // true
console.log(u1 instanceof Person); // true
console.log(u1 instanceof Object); // true
console.log(u1.constructor);  // User Class
```
 
## Arrays

### Q. Explain Arrays in details with all methods and examples?

There are two fundamental ways to create new array:

- Using the built-in Array constructor
- Using array literals []

```js
const users = ['John','Cena','Randy Ortan', 'Undertaker'];  // Using array literal

const users = new Array(); // Empty array
const users = new Array('John','Cena','Randy Ortan', 'Undertaker');  // Using Array constructor
```

**`Add or Remove item from Beginning or End of an Array`**

- `push`: adds an item to the end of the array
- `unshift`: adds an item to the beginning of the array
- `pop`: removes an item from the end of the array
- `shift`: removes an item from the beginning of the array

**`Add or Remove items at any array location`**

The `splice()` method changes the contents of an array by removing or replacing existing elements and/or adding new elements in place. It changes the exisitng array and returns the deleted items.

`Syntax`:
```js
splice(start)
splice(start, deleteCount)
splice(start, deleteCount, item1)
splice(start, deleteCount, item1, item2, itemN)
```

`Remove 0 (zero) elements before index 2, and insert "drum"`
```js
let myFish = ['angel', 'clown', 'mandarin', 'sturgeon']
let removed = myFish.splice(2, 0, 'drum')

// myFish is ["angel", "clown", "drum", "mandarin", "sturgeon"]
// removed is [], no elements removed
```

`Remove 0 (zero) elements before index 2, and insert "drum" and "guitar"`
```js
let myFish = ['angel', 'clown', 'mandarin', 'sturgeon']
let removed = myFish.splice(2, 0, 'drum', 'guitar')

// myFish is ["angel", "clown", "drum", "guitar", "mandarin", "sturgeon"]
// removed is [], no elements removed
```

`Remove 1 element at index 3`
```js
let myFish = ['angel', 'clown', 'drum', 'mandarin', 'sturgeon']
let removed = myFish.splice(3, 1)

// myFish is ["angel", "clown", "drum", "sturgeon"]
// removed is ["mandarin"]
```

`Remove 1 element at index 2, and insert "trumpet"`
```js
let myFish = ['angel', 'clown', 'drum', 'sturgeon']
let removed = myFish.splice(2, 1, 'trumpet')

// myFish is ["angel", "clown", "trumpet", "sturgeon"]
// removed is ["drum"]
```

`Remove 2 elements from index 0, and insert "parrot", "anemone" and "blue"`
```js
let myFish = ['angel', 'clown', 'trumpet', 'sturgeon']
let removed = myFish.splice(0, 2, 'parrot', 'anemone', 'blue')

// myFish is ["parrot", "anemone", "blue", "trumpet", "sturgeon"]
// removed is ["angel", "clown"]
```

`Remove 1 element from index -2 (Takes it from the end)`
```js
let myFish = ['angel', 'clown', 'mandarin', 'sturgeon']
let removed = myFish.splice(-2, 1)

// myFish is ["angel", "clown", "sturgeon"]
// removed is ["mandarin"]
```

`Remove all elements, starting from index 2`
```js
let myFish = ['angel', 'clown', 'mandarin', 'sturgeon']
let removed = myFish.splice(2)

// myFish is ["angel", "clown"]
// removed is ["mandarin", "sturgeon"]
```

**`Iterating over arrays`**

There are two ways to iterate over arrays:
1. Using for loop
2. Using built-in forEach method of Array prototype

`Using for loop`:
```js
let myFish = ['angel', 'clown', 'mandarin', 'sturgeon']
for(let i = 0; i < myFish.length; i++){
	//Perform any operation on myFish[i]
}
```

`Using built-in forEach method`:
```js
myFish.forEach(data => {
	console.log(data);
});

//To use index in built-in method
myFish.forEach((data, index) => {
	console.log(data, index);
});
```

**`Mappng Arrays`**

The `map()` method creates a new array populated with the results of calling a provided function on every element in the calling array.

`Eg: Mapping an array of numbers to an array of square roots`

```js
let numbers = [1, 4, 9]
let roots = numbers.map(function(num) {
    return Math.sqrt(num)
})
// roots is now     [1, 2, 3]
// numbers is still [1, 4, 9]
```

`Eg: Get property array from Array of Object`
```js
const users = [
	{name: 'John', city: 'US'}, 
	{name: 'Cena', city: 'Maxico'},
	{name: 'Shane', city: 'Delhi'},
	{name: 'Watson', city: 'Pune'}
];

//Get all cities as array
const cities = users.map((user) => {
	return user.city;
});

console.log(cities); // ['US', 'Maxico', 'Delhi', 'Pune'];
```

`Eg: Mapped array contains undefined`

```js
let numbers = [1, 2, 3, 4]
let filteredNumbers = numbers.map(function(num, index) {
  if (index < 3) {
     return num
  }
})
// index goes from 0, so the filterNumbers are 1,2,3 and undefined.
// filteredNumbers is [1, 2, 3, undefined]
// numbers is still [1, 2, 3, 4]
```

**`Testing Array Items`**

When we work with collection of arrays then we need to check whether all or some of the items satisfy the condition. So, in JS, there are two built-in methods that can be used: `some` and `every`.

`Check if some of the users are admin or not`
```js
const users = [
	{name: 'John', city: 'US', isAdmin: false }, 
	{name: 'Cena', city: 'Maxico', isAdmin: true },
	{name: 'Shane', city: 'Delhi', isAdmin: true },
	{name: 'Watson', city: 'Pune', isAdmin: true }
];

const areSomeAdmins = users.some((user) => {
	return user.isAdmin === true;
});

const areAllAdmins = users.every((user) => {
	return user.isAdmin === true;
});
```

**`Searching Arrays`**

`find`: The `find()` method returns the value of the first element in the provided array that satisfies the provided testing function.

`Eg: Find an object in an array by one of its properties`

```js
const inventory = [
  {name: 'apples', quantity: 2},
  {name: 'bananas', quantity: 0},
  {name: 'cherries', quantity: 5}
];

function isCherries(fruit) {
  return fruit.name === 'cherries';
}

console.log(inventory.find(isCherries));
// { name: 'cherries', quantity: 5 }
```

`Using arrow function and destructuring`
```js
const inventory = [
  {name: 'apples', quantity: 2},
  {name: 'bananas', quantity: 0},
  {name: 'cherries', quantity: 5}
];

const result = inventory.find( ({ name }) => name === 'cherries' );

console.log(result) // { name: 'cherries', quantity: 5 }
```

**`Filtering Array`**

The `filter()` method creates a new array with all elements that pass the test implemented by the provided function.

`Filtering out all small values`
The following example uses filter() to create a filtered array that has all elements with values less than 10 removed.
```js
function isBigEnough(value) {
  return value >= 10
}

let filtered = [12, 5, 8, 130, 44].filter(isBigEnough)
// filtered is [12, 130, 44]
```

`Find all prime numbers in an array`
```js
const array = [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];

function isPrime(num) {
  for (let i = 2; num > i; i++) {
    if (num % i == 0) {
      return false;
    }
  }
  return num > 1;
}

console.log(array.filter(isPrime)); // [2, 3, 5, 7, 11, 13]
```

`Filter the items from an array`
```js
const inventory = [
  {name: 'apples', quantity: 2},
  {name: 'bananas', quantity: 0},
  {name: 'cherries', quantity: 5}
];

const filteredItems = inventory.filter((inv) => {
	return inv.quantity > 0;
});
```

**`Finding Index from Beginning and End of an array`**

**`findIndex`**
The `findIndex()` method returns the index of the first element in the array that satisfies the provided testing function. Otherwise, it returns -1, indicating that no element passed the test.

`findIndex from normal array`
```js
const array1 = [5, 12, 8, 130, 44];

const isLargeNumber = (element) => element > 13;

console.log(array1.findIndex(isLargeNumber));
// expected output: 3
```

`findIndex from collection of objects`
```js
const inventory = [
  {name: 'apples', quantity: 2},
  {name: 'bananas', quantity: 0},
  {name: 'cherries', quantity: 5}
];

const itemIndex = inventory.findIndex((item) => {
	return item.name === 'bananas';
});
```

**`indexOf`**

The `indexOf()` method returns the first index at which a given element can be found in the array, or -1 if it is not present.

```js
indexOf(searchElement)
indexOf(searchElement, fromIndex)
```

```js
const beasts = ['ant', 'bison', 'camel', 'duck', 'bison'];

console.log(beasts.indexOf('bison'));
// expected output: 1

// start from index 2
console.log(beasts.indexOf('bison', 2));
// expected output: 4

console.log(beasts.indexOf('giraffe'));
// expected output: -1
```

```js
var array = [2, 9, 9];
array.indexOf(2);     // 0
array.indexOf(7);     // -1
array.indexOf(9, 2);  // 2
array.indexOf(2, -1); // -1
array.indexOf(2, -3); // 0
```

**`lastIndexOf`**
The `lastIndexOf()` method returns the last index at which a given element can be found in the array, or -1 if it is not present. The array is searched backwards, starting at fromIndex.

```js
lastIndexOf(searchElement)
lastIndexOf(searchElement, fromIndex)
```

```js
const animals = ['Dodo', 'Tiger', 'Penguin', 'Dodo'];

console.log(animals.lastIndexOf('Dodo'));
// expected output: 3

console.log(animals.lastIndexOf('Tiger'));
// expected output: 1
```

```js
var numbers = [2, 5, 9, 2];
numbers.lastIndexOf(2);     // 3
numbers.lastIndexOf(7);     // -1
numbers.lastIndexOf(2, 3);  // 3
numbers.lastIndexOf(2, 2);  // 0
numbers.lastIndexOf(2, -2); // 0
numbers.lastIndexOf(2, -1); // 3
```

**`Aggregating Array Items`**

`Problem`
```js
const numbers = [1,2,3,4,5];
const sum = 0;

numbers.forEach((num) => sum += num;);

console.log(sum); // 15
```

`Right Solution`
```js
const sum = numbers.reduce((aggregated, number) => {
	return aggregated + number;
}, 0);
```
The `reduce()` method executes a user-supplied reducer callback function on each element of the array, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the array is a single value.

**`Slicing Array`**

The `slice()` method returns a shallow copy of a portion of an array into a new array object selected from start to end (end not included) where start and end represent the index of items in that array. The original array will not be modified.

```js
const animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];

console.log(animals.slice());
// expected output: Array ['ant', 'bison', 'camel', 'duck', 'elephant']

console.log(animals.slice(0));
// expected output: Array ['ant', 'bison', 'camel', 'duck', 'elephant']

console.log(animals.slice(2));
// expected output: Array ["camel", "duck", "elephant"]

console.log(animals.slice(2, 4));
// expected output: Array ["camel", "duck"]

console.log(animals.slice(1, 5));
// expected output: Array ["bison", "camel", "duck", "elephant"]

console.log(animals.slice(-2));
// expected output: Array ["duck", "elephant"]

console.log(animals.slice(2, -1));
// expected output: Array ["camel", "duck"]
```

### Q. How many ways to empty an array ?

There are 4 ways to empty an array:

```js
let users = ['Harman', 'Priyanshi', 'Chetan'];
```

1. **`By Assigning it to a new empty array`**

```js
users = [];
```

2. **`Setting its length to zero`**

```js
users.length = 0;
```

3. **`Using splice method`**

```js
users.splice(0, users.length);
```

4. **`Using pop`**

```js
while(users.length > 0){
	users.pop();
}
```

### Q. How do you check if an object is an array or not?

```js
let users = ['Harman', 'Priyanshi', 'Chetan'];

Array.isArray(users); // true

users instanceof Array; // true

users.constructor === Array; //true

```

### Q. How do you iterate over string ?

```js
const userName = "Harman";

const nameArr = userName.split("");

//1. Using split and normal loop
for (let i = 0; i < nameArr.length; i++) {
  console.log(nameArr[i]);
}

//2. Using for..of loop
for (const val of userName) {
  console.log(val);
}

```

---

## Functions

### Q. What are first class functions or functions as first class citizens?

Functions in JavaScript possess all the capabilities of objects and are thus treated like any other object in the language. We say that functions are first-class objects, which can also be:

- **`Created via literals`**
```js
function getDetails() {}
```

- **`Assigned to variables, array entries, and properties of other objects`**
```js
var ninjaFunction = function() {}; 
ninjaArray.push(function(){});     
ninja.data = function(){};   
```

- **`Passed as arguments to other functions`**
```js
function getNinja(ninjaFunction){
  ninjaFunction();
}
getNinja(function(){}); 
```

- **`Returned as values from functions`**
```js
function returnNewNinjaFunction() {
  return function(){}; 
}
```

- **`They can possess properties that can be dynamically created and assigned:`**
```js
var ninjaFunction = function(){};
ninjaFunction.name = "Hanzo";
```

### Q. What are named function expression ?

If you want to refer to the current function inside the function body, you need to create a named function expression. This name is then local only to the function body (scope).
```js
let math = {
  'factit': function factorial(n) {
    console.log(n)
    if (n <= 1) {
      return 1;
    }
    return n * factorial(n - 1);
  }
};

math.factit(3) //3;2;1;
```

### Q. What is the difference between function statement, function declaration and function expression?

`function declaration`:

```js
function calcRectArea(width, height) {
  return width * height;
}
```

`function expression`:

```js
const calcRectArea = function(width, height) {
  return width * height;
}
```

1. The main difference between a function expression and a function declaration is the function name, which can be omitted in function expressions to create anonymous functions. A function expression can be used as an IIFE (Immediately Invoked Function Expression) which runs as soon as it is defined.

2. Function expressions in JavaScript are not hoisted, unlike function declarations. You can't use function expressions before you create them. Function declarations load in the memory before any code is executed while Function expressions load only when the interpreter reaches that line of code.

### Q. What are callback functions?

A callback is a function passed into another function as an argument which can be executed later. Example:

```js
function btnClicked() { // callback function
   // do something here
}
let btn = document.querySelector('#btn');
btn.addEventListener('click',btnClicked);
```

There are two types of callback: Synchronous and Asynchronous.

**Synchronous Callbacks** are those in which there is no delay or side effects to call the callback like array filter, map, forEach, event button click.

**Asynchronous Callbacks** are those in which javascript wait for the primary operation to complete then execute callback. For example:

```js
function download(url, callback) {
    setTimeout(() => {
        // script to download the picture here
        console.log(`Downloading ${url} ...`);
        
        // process the picture once it is completed
        callback(url);
    }, 3000);
}

function process(picture) {
    console.log(`Processing ${picture}`);
}

let url = 'https://wwww.javascripttutorial.net/pic.jpg';
download(url, process);
```

### Q. What are self memorizing functions?

### Q. What is pure function ?
`Pure function` is a function which always returns the **same result if the same argument is passed**. It does not depend on any state, or data change during a programs execution rather it only depends on its input arguments. Also a pure function does not produce any API side effects such as network requests or data mutation etc.

```javascript
function calculateGST(productPrice) {
    return productPrice * 0.05;
}
```

### Q. What is Hoisting, how does variables and function declarations works behind the scene.
JavaScript `Hoisting` refers to the process whereby the interpreter allocates memory for variable and function declarations prior to execution of the code. Declarations that are made using `var` are initialized with a default value of undefined. Declarations made using `let` and `const` are not initialized as part of hoisting.

Conceptually hoisting is often presented as the interpreter "splitting variable declaration and initialization, and moving (just) the declarations to the top of the code". This allows variables to appear in code before they are defined. 

### Q. What is IIFE (Immediately Invoked Functional Expression?)
An IIFE (Immediately Invoked Function Expression) is a JavaScript function that runs as soon as it is defined. 
```js
(function () {
  statements
})();
```

**Benefits of using IIFE**:
- **Avoid polluting the global namespace**: 
```js
(function () {
  // some initiation code
  let firstVariable;
  let secondVariable;
})();

// firstVariable and secondVariable will be discarded after the function is executed.
```
Here, `firstVariable` and `secondVariable` will not be created in the functional scope and these variables will be discarded upon function execution. As we will not reuse the code again, using IIFE in this case is better than using a function declaration or a function expression.

- **The module pattern**
We can also use IIFE to create module in javascript in which only the required functionality will be returned from the IIFE and the actual functionality will be part of the IIFE.

```js
const personModule = (function() {
    let _p = {
        startWork: () => {
            //Actual
        }
    };
    
    //Private Functionality
    
    let p = {
        start: () => {
            _p.startWork();
        }
    };
    //Public interface


    return p;

})();

console.log(personModule)
```

### Q. What are implicit function parameters?

Function calling passed two implicit parameters: `arguments` and `this`.

By implicit means, they are not actually listed in the function signature, but are silently passed to the function and accessible within the function.

`argument parameter`:
argument parameter is a collection of all arguments passed to a function. It is useful because it allows us to access all the function arguments. So, the need of the arguments is reduced due to `rest` parameter introduced in ES6.

```js
function whatever(a, b, c){                  
  
  assert(a === 1, 'The value of a is 1');    
  assert(b === 2, 'The value of b is 2');    
  assert(c === 3, 'The value of c is 3');    

  assert(arguments.length === 5,             
    'Weve passed in 5 parameters');         

  assert(arguments[0] === a, 'The first argument is assigned to a');  
  assert(arguments[1] === b, 'The second argument is assigned to b'); 
  assert(arguments[2] === c, 'The third argument is assigned to c');
  assert(arguments[3] === 4, 'We can access the fourth argument');    
  assert(arguments[4] === 5, 'We can access the fifth argument');     
}

whatever(1,2,3,4,5);
```
So, here arguments is array like collection but its not actual array. You can access length property of it but can't sort, filter and other array function can't be applied on it. However, if you use `rest` parameter then it will be an array and all useful array functions can be applied on it. This is the beauty of using rest instead of arguments.

**`Changing Value of arguments directly impacts the parameters`**
```js
function infiltrate(person) {
  assert(person === 'gardener', 'The person is a gardener');        
  assert(arguments[0] === 'gardener', 'The first argument is a gardener');

  arguments[0] = 'ninja';                

  assert(person === 'ninja', 'The person is a ninja now');        
  assert(arguments[0] === 'ninja', 'The first argument is a ninja');    

  person = 'gardener';                        

  assert(person === 'gardener', 'The person is a gardener once more');    
  assert(arguments[0] === 'gardener', 'The first argument is a gardener again');
}

infiltrate("gardener");
```

**`Using use strict with arguments`**
```js
"use strict";          

function infiltrate(person){
  assert(person === 'gardener', 'The person is a gardener');         
  assert(arguments[0] === 'gardener', 'The first argument is a gardener'); 

  arguments[0] = 'ninja';             

  assert(arguments[0] === 'ninja', 'The first argument is now a ninja');  
  assert(person === 'gardener', 'The person is still a gardener');     
}

infiltrate("gardener");
```

### Q. What is this parameter and how it works in all function calls?

`this` refers to an object that's associated with the function invocations, inshorts who is calling the function will refer to this inside the function.

There are 4 ways to invoke a function:
- As a function
- As a method
- As a constructor
- Using apply or call method

**`As a function`**
```js
function getDetails(){
	console.log(this);	
}

function getDetailsWithStrict(){
	'use strict';
	console.log(this);	
}

const arrowFn = () => {
	"use strict";
	console.log(this);
}
```

```js
window
undefined
window
```

In `non-strict` mode, it will be the global context (`window` object), whereas in `strict mode`, it will be `undefined`.

**`As a method`**
When we invoke a function as a method of an object, then that object becomes the function context and is available within the function via `this` parameter.

```js
function whatsMyContext() {     
	return this;                  
}
if(whatsMyContext() === window) {
	console.log('Widow context');
}

var ninja1 = {                      
  getMyThis: whatsMyContext         
}; 

console.log(ninja1.getMyThis());	// Returned ninja1 object

let ninja2 = {
	whatMyThis: function() {
		console.log(this);	// ninja2 object
	},
	whatMyArrowThis: () => {
		console.log(this);	// window
	}
}
```

**`As a constructor`**
```js
function Person() {
  this.getUser = function() {
    console.log(this)
  }

  this.getUserArrow = function() {
    console.log(this);
  }
}

const p1 = new Person();
p1.getUser();     // p1
p1.getUserArrow();    // p1
```

### Q. What if a constructor is returning a value?

- If the constructor returns an object, that object is returned as the value of the whole new expression and the newly constructed object passed as this to the constructor is discarded
- If a nonobject is returned from the constructor, the returned value is ignored and the newly created object is returned.

`Case 1: When object returned from the constructor`
```js
const userObj = {
  name: 'Priyanshi'
}

function Person(userName) {
  this.username = userName;

  return userObj;
}


const p1 = new Person('Harman');
console.log(p1);      // Points to userObj
```

`Case 2: When nonobject returned from the constructor`
```js
const rollNo = 10;

function Person(userName) {
  this.username = userName;

  return rollNo ;
}


const p1 = new Person('Harman');
console.log(p1);      // p1 object of Person constructor
```

```js
//Normal Function
//This - Arrow -> window
//this - normalFn -> window

//Object Function
//This -> Arrow -> window
//This -> normalFn -> the calling object

//Constructor Function's method
//this -> Arrow -> the calling object
//this -> normalFb -> the calling object
```

### Q. What is call and apply method?

Javascript provides a way to invoke a function and to explicitly specify any object we want as the function context. This can be possible by using call and apply methods.

**`apply:`** 
To invoke a function by using its apply method, we pass two parameters to apply
- object to be used as a function context
- array of values to be used as the function arguments

**`call:`**
To invoke a function by using its call method, we pass parameters:
- object to be used as a function context
- list of parameters separate by commas

```js
function showUserDetails(city, state) {
  console.log(
    `${this.name} is very good person having ${this.years} of experience. He lives in ${city}, ${state}`
  );
}

const user = {
  name: "Harman",
  years: "3",
};

showUserDetails.apply(user, ["Bangalore", "Karnataka"]);
// Harman is very good person having 3 of experience. He lives in Bangalore, Karnataka

const user2 = {
  name: 'Priyanshi',
  years: 2
}

showUserDetails.call(user2, 'Bangalore', 'Karnataka');
// Priyanshi is very good person having 2 of experience. She lives in Bangalore, Karnataka
```

### Q. How does bind works in Javascript?

The `bind` method is available to all the functions, and is designed to create and return a new function that is bound to the passed-in object. The value of `this` parameter is always set to that object, regardless of the way bound function is called. This function has the same body as that of the original function. So, calling the bind function does not modify the original function.

```js
function getDetails(city, state) {
  console.log(`${this.username} ${this.rollNo} lives in ${city} ${state}`);
}

const obj1 = {
  username: "Harman",
  rollNo: 12,
  class: "8th",
};


const data = ["Bengaluru", "Karnataka"];

//Call
getDetails.call(obj1, "Bengaluru", "Karnataka");
//Harman 12 lives in Bengaluru Karnataka

//Apply
getDetails.apply(obj1, data);
//Harman 12 lives in Bengaluru Karnataka

//Bind
const getDetailsLater = getDetails.bind(obj1, ...data);
getDetailsLater();
//Harman 12 lives in Bengaluru Karnataka
```

### Q. What is promise in javascript?

In JavaScript, a `promise` is a good way to handle **asynchronous** operations. It is used to find out if the asynchronous operation (api call) is successfully completed or not.

A promise may have one of three states.
- Pending
- Fulfilled
- Rejected

A promise starts in a pending state. That means the process is still in-progress. If the operation is successful, the process ends in a `fulfilled` state. And, if an error occurs, the process ends in a `rejected` state.

For example, when you request data from the server by using a promise, it will be in a pending state. When the data arrives successfully, it will be in a fulfilled state. If an error occurs, then it will be in a rejected state.

**Create a Promise**

To create a promise object, we use the `Promise()` constructor.

```js
const promise = new Promise((resolve, reject) => {
	// Execute long delay task here
	// Core business logic like api call etc
});
```
The function passed to new Promise is called the ***executor***. When new Promise is created, the executor runs automatically. This function is responsible for manking any api call, any task which takes time and once that task is finished, based on the result from the task it should either call `resolve()` or `reject()`.

When the executor obtains the result, be it soon or late, doesnt matter, it should call one of these callbacks:
- **resolve(value)** - if the job is finished successfully, with result `value`.
- **reject(error)** - if an error has occurred, `error` is the error object.

The `promise` object returned by the `new Promise` constructor has these internal properties:

- **state** - initially `pending`, then changes to either `fulfilled` when `resolve` is called or `rejected` when `reject` is called.
- **result** - initially `undefined`, then changes to value when `resolve(value)` called or error when `reject(error)` is called.

So the `executor` eventually moves promise to one of these states:

<div align="center">
	<img src="https://user-images.githubusercontent.com/50094184/142371561-ec0ff6a6-4e20-41dd-a0b4-ca4d5b6e3f90.png" width="60%" />
</div>

**Consumers: then, catch, finally**

**EXAMPLE**
```js
console.log("Created Promise")
const promiseObj = new Promise((resolve, reject) => {
  
  const responseData = {
    name: "Harman",
    rollNo: 12,
  };
  console.log("Inside executor function")
  //Perform API Call. Mocking here with 2000ms 
  setTimeout(() => {
    console.log("Resolving Promise")
    resolve(responseData);
    console.log("resolving promise ends")
  }, 2000);

});
console.log("Subscribing promose");
promiseObj
  .then((data) => {
    console.log("Data Received: ", data);
  })
  .catch((error) => {
    console.log(error);
  }).finally(() => {
    console.log("Promise finally...")
  })
console.log("Program ends.")
```

**OUTPUT**
```js
Created Promise
Inside executor function
Subscribing promose
Program ends.
Resolving Promise
resolving promise ends
Data Received:  {name: 'Harman', rollNo: 12}
Promise finally...
```

### Q. What is promise chaining?

Promise Chaining will be achived by `then` and `catch` methods of Promise. The output of the first asynchronous operation is used as the input of the second one, and so on.

```js
// Create a Promise
let promise = new Promise(function(resolve, reject) {
    resolve('Resolving a fake Promise.');
});

// Handle it using the .then() handler
promise.then(function(value) {
    console.log(value);
})
```

**OUTPUT**
```js
Resolving a fake Promise.
```

**`Return a promise from the .then() handler`**

You can return a promise from a `.then()` handler method. You will go for it when you have to initiate an async call based on a response from a previous async call.

```js
// Create a Promise
let getUser = new Promise(function(resolve, reject) {
    console.log('Running Promise executor');
    const user = { 
           name: 'John Doe', 
           email: 'jdoe@email.com', 
           password: 'jdoe.password' 
     };
   resolve(user);
});

getUser.then(function(user) {
    console.log(`Got user ${user.name}`);
    // Return a Promise
    return new Promise(function(resolve, reject) {
        setTimeout(function() {
            // Fetch address of the user based on email
            resolve('Bangalore');
         }, 1000);
    });
})
.then(function(address) {
    console.log(`User address is ${address}`);
});

console.log("Program ends..");
```

**OUTPUT**
```js
Running Promise executor
Program ends..
Got user John Doe
User address is Bangalore
```

**`Return a simple value from the .then() handler`**

In many situations, you may not have to make an async call to get a value. You may want to retrieve it synchronously from memory or cache. You can return a simple value from the .then() method than returning a promise in these situations.

```js
// Create a Promise
let getUser = new Promise(function(resolve, reject) {
   const user = { 
           name: 'John Doe', 
           email: 'jdoe@email.com', 
           password: 'jdoe.password' 
    };
    resolve(user);
});

getUser
.then(function(user) {
    console.log(`Got user ${user.name}`);
    // Return a simple value
    return user.email;
})
.then(function(email) {
    console.log(`User email is ${email}`);
});
```

**OUTPUT**
```js
Got user John Doe
User email is jdoe@email.com
```

**`Throw an error from the .then() handler`**

You can `throw` an error from the `.then()` handler. If you have a `.catch()` method down the chain, it will handle that error. If we don't handle the error, an `unhandledrejection` event takes place. It is always a good practice to handle errors with a `.catch()` handler, even when you least expect it to happen.

```js
let getUser = new Promise(function(resolve, reject) {
    const user = { 
        name: 'John Doe', 
        email: 'jdoe@email.com', 
        permissions: [ 'db', 'hr', 'dev']
    };
    resolve(user);
});

getUser
.then(function(user) {
    console.log(`Got user ${user.name}`);
    // Let's reject if a dev is having the HR permission
    if(user.permissions.includes('hr')){
        throw new Error('You are not allowed to access the HR module.');
    }
    // else resolve as usual
})
.then(function(email) {
    console.log(`User email is ${email}`);
})
.catch(function(error) {
    console.error(error)
});
```

**OUTPUT**
```js
Got user John Doe
Error: You are not allowed to access the HR module.
```

**`Rethrow from catch`**

You can rethrow from the `.catch()` handler to handle the error later. In this case, the control will go to the next **closest** `.catch()` handler.

```js
// Craete a promise
var promise = new Promise(function(resolve, reject) {
    reject(401);
});

// catch the error
promise
.catch(function(error) {
    if (error === 401) {
        console.log('Rethrowing the 401');
        throw error;
    } else {
        // handle it here
    }
})
.then(function(value) {
    // This one will not run
    console.log(value);
}).catch(function(error) {
    // Rethrow will come here
    console.log(`handling ${error} here`);
});
```

**OUTPUT**
```js
Rethrowing the 401
handling 401 here
```

**`finally()`**

We can run the `.finally()` handler on a settled promise(resolved or rejected). It is a handy method to perform any cleanup operations like stopping a loader, closing a connection and many more. Also note, the .finally() handler `doesn't` have any arguments.


```js
// Create a Promise
let promise = new Promise(function(resolve, reject) {
    resolve('Testing Finally.');
});

promise.then(function(value) {
    console.log(value);
}).finally(function() {
    console.log('Running .finally()');
});
```
**OUTPUT**
```js
Testing Finally
Running .finally()
```

```js
// Create a Promise
let promise = new Promise(function(resolve, reject) {
    resolve('Testing Finally.');
});

// Run .finally() before .then()
promise.finally(function() {
    console.log('Running .finally()');
}).then(function(value) {
    console.log(value);
});
```

**OUTPUT**
```js
Running .finally()
Testing Finally
```

**`Calling multiple then on a single promise is NOT chaining`**

Calling the .then() handler method multiple times on a single promise is NOT chaining.

```js
// Create a Promise
let promise = new Promise(function (resolve, reject) {
  resolve(10);
});

// Calling the .then() method multiple times
// on a single promise - It's not a chain
promise.then(function (value) {
  value++;
  return value;
});
promise.then(function (value) {
  value = value + 10;
  return value;
});
promise.then(function (value) {
  value = value + 20;
  console.log(value);
  return value;
});
```

**OUTPUT**
```js
30
```

**`JANGO TRICKY 1`**

```js
function getData(isVal) {
  return new Promise((resolve, reject) => {
    if (isVal) {
      resolve("Success");
    } else {
      reject("FAILED");
    }
  });
}

getData(true)
  .then((data) => {
    console.log("First then: ", data);
  })
  .catch((error) => {
    console.log(error);
    return "Error Message Another";
  })
  .then((data) => {
    console.log("2nd then: ", data);
  })
  .catch((error) => {
    console.log(error);
  });
```

**OUTPUT**
```js
First then: Success
2nd then: undefined
```

**`JANGO TRICKY 2`**

```js
function getData(isVal) {
  return new Promise((resolve, reject) => {
    if (isVal) {
      resolve("Success");
    } else {
      reject("FAILED");
    }
  });
}

getData(true)
  .then((data) => {
    console.log("First then: ", data);
    return "Harman"
  })
  .catch((error) => {
    console.log(error);
    return "Error Message Another";
  })
  .then((data) => {
    console.log("2nd then: ", data);
  })
  .catch((error) => {
    console.log(error);
  });

```

**OUTPUT**
```js
First then: Success
2nd then: Harman
```

**`JANGO TRICKY 3`**

```js
function getData(isVal) {
  return new Promise((resolve, reject) => {
    if (isVal) {
      resolve("Success");
    } else {
      reject("FAILED");
    }
  });
}

getData(false)
  .then((data) => {
    console.log("First then: ", data);
    return "Harman";
  })
  .catch((error) => {
    console.log(error);
    return "Error Message Another";
  })
  .then((data) => {
    console.log("2nd then: ", data);
  })
  .catch((error) => {
    console.log(error);
  })
  .catch((error) => {
    console.log(error);
  });
```

**OUTPUT**
```js
FAILED
2nd then: Error Message Another
```

**`JANGO TRICKY 4`**

```js
function getData(isVal) {
  return new Promise((resolve, reject) => {
    if (isVal) {
      resolve("Success");
    } else {
      reject("FAILED");
    }
  });
}

getData(true)
  .then((data) => {
    console.log("First then: ", data);
    return "Harman";
  })
  .catch((error) => {
    console.log(error);
    return "Error Message Another";
  })
  .then((data) => {
    console.log("2nd then: ", data);
  })
  .catch((error) => {
    console.log(error);
  })
  .catch((error) => {
    console.log(error);
  })
  .then((data) => {
    console.log("Last then: ", data);
  });
```

**OUTPUT**
```js
First then: Success
2nd then: Harman
Last then: undefined
```

**`JANGO TRICKY 5`**

```js
function getData(isVal) {
  return new Promise((resolve, reject) => {
    if (isVal) {
      resolve("Success");
    } else {
      reject("FAILED");
    }
  });
}

getData(false)
  .then((data) => {
    console.log("First then: ", data);
    return "Harman";
  })
  .catch((error) => {
    console.log(error);
    return "Error Message Another";
  })
  .then((data) => {
    console.log("2nd then: ", data);
  })
  .catch((error) => {
    console.log(error);
  })
  .catch((error) => {
    console.log(error);
  })
  .then((data) => {
    console.log("Last then: ", data);
  });
```

**OUTPUT**
```js
FAILED
2nd then: Error Message Another
Last then: undefined
```

**`JANGO TRICKY 6`**

```js
function getData(isVal) {
  return new Promise((resolve, reject) => {
    if (isVal) {
      resolve("Success");
    } else {
      reject("FAILED");
    }
  });
}

getData(false)
  .then((data) => {
    console.log("First then: ", data);
    return "Harman";
  })
  .then((data) => {
    console.log("2nd then: ", data);
  })
  .catch((error) => {
    console.log(error);
    return "Error Message Another";
  })
  .catch((error) => {
    console.log(error);
  })
  .catch((error) => {
    console.log(error);
  });
```

**OUTPUT**
```js
FAILED
```

**`JANGO TRICKY 7`**

```js
function getData(isVal) {
  return new Promise((resolve, reject) => {
    if (isVal) {
      resolve("Success");
    } else {
      reject("FAILED");
    }
  });
}

getData(false)
  .then((data) => {
    console.log("First then: ", data);
    return "Harman";
  })
  .then((data) => {
    console.log("2nd then: ", data);
  })
  .catch((error) => {
    console.log(error);
    throw new Error("Error Message Another");
  })
  .catch((error) => {
    console.log("Second Catch:" , error);
  })
  .catch((error) => {
    console.log(error);
  });
```

**OUTPUT**
```js
FAILED
Second Catch: Error: Error Message Another
```

## Events

### Q. Define Event Capturing and Bubbling?

`Event Bubbling:` When an event happens on an element, it first runs the handlers on it, then on its parent, then all the way up on other ancestors. 

<p align="center">
<img src="https://user-images.githubusercontent.com/50094184/136601992-b3721653-92f3-4085-a0c7-10f662aaa808.png" width="40%" />
</p>

A click on the inner `<p>` first runs onclick:

1. On that `<p>`.
2. Then on the outer `<div>`.
3. Then on the outer `<form>`.
4. And so on upwards till the document object.

<p align="center">
    <img width="20%" src="https://user-images.githubusercontent.com/50094184/136814777-ff263d77-44f2-4849-a171-81990ab3d3e0.png" />
</p>


`Event Capturing:` The event is first captured at the outermost element and then at the innermost element (target element)

<p align="center">
    <img width="20%" src="https://user-images.githubusercontent.com/50094184/136813406-d8c04a22-6936-49f3-a35e-8f14260771f5.png" />
</p>


#### Complete Concept

<p align="center">
    <img width="60%" src="https://user-images.githubusercontent.com/50094184/136812688-d056886a-07a3-4942-96a7-918152687057.png" />
</p>

### Q. What is Event Delegation ?

Event Delegation is basically a pattern to handle events efficiently. Instead of adding an event listener to each and every similar element, we can add an event listener to a parent element and call an event on a particular target using the `.target` property of the event object.

```js
const customUl = document.createElement('ul');

function responding(evt) {
    if (evt.target.nodeName === 'li')
        console.log('Responding')
}

for (var i = 1; i <= 10; i++) {
    const newElement = document.createElement('li');
    newElement.textContent = "This is line " + i;
    customUI.appendChild(newElement);
}

customUI.addEventListener('click', responding);
```

### Q. What is Event Propagation and how do you stop propagation ?

By default, events will bubble up to the document. So, if onClick is registered on `<a>` it will trigger its onClick and if any of the parent elements are registered with onClick event handler then their onClicks will also trigger. This is vague condition when you only need the target element to be triggered and no other bubbled up events.

For this condition, we do `event.stopPropagation()` this will stop the bubbling phase of the event to the DOM.

```js
const handleCheck = e => {
  e.stopPropagation()
  
}
<span onClick={handleCheck}>Button</span>
```

### Q. What is event.preventDefault ?

Event.preventDefault means that the default behaviour of the event will not occur. Examples:

- Clicking on Submit button will not submit the form
- Clicking on link prevent it from following the url

Note: Not all the events are cancelable, only those events are cancellable whose event.cancelable returns true.

```js
const handleCheck = e => {
  console.log(e.cancelable); //true
  e.stopPropagation()
  
}
<span onClick={handleCheck}>Button</span>
```

### Q. Event Queue

1. Macro Task Queue
	Examples: setTimout
2. Micro Task Queue
	Examples: Promise

```js
setTimeout(() => console.log("Set Timeout Ran"));

Promise.resolve().then(() => console.log("Promise Ran"));

console.log("Main execution ");

```

```js
Main execution 
Promise Ran
Set Timeout Ran
```

In the above example, First the main execution context (Macro Task) will start executing the code and moved setTimeout to the Macro Task Queue and Promise to the Micro Task Queue. Once, main execution finishes it will pick all the tasks available in the Micro Tasks Queue and start executing them one by one, once the Micro Task Queue is empty then it will pick one task from Macro Task queue upon its finishes it will again go and pick all tasks from Micro Task Queue and this process continues.

### Q. Explain Event Queue ?

## New Features of ES6

### Generator functions
A normal function can only return single value from the function and it clears its execution context once it completes its execution. If we need to return multiple values from the function then we can use generator function. Its a function which can be stopped in the midway and then continue from where it is stopped.

- A generator is a function that produces a sequence of results instead of a single value, i.e you generate a series of values.

In JavaScript, a generator is a function which returns an object on which you can call `next()`. Every invocation of `next()` will return an object:

```js
{ 
  value: Any,
  done: true|false
}
```

The `value` property will contain the value. The `done` property is either `true` or `false`. When the done becomes `true`, the generator stops and wont generate any more values.

<div align="center">
	<img src="https://user-images.githubusercontent.com/50094184/141467758-dd59b3c0-619a-43da-b066-ab78dca42300.png" width="60%" />
</div>

**Creating a Generator**

```js
function * generatorFunction() { // Line 1
  console.log('This will be executed first.');
  yield 'Hello, ';   // Line 2
  console.log('I will be printed after the pause');  
  yield 'World!';
}
const generatorObject = generatorFunction(); // Line 3
console.log(generatorObject.next().value); // Line 4
console.log(generatorObject.next().value); // Line 5
console.log(generatorObject.next().value); // Line 6
// This will be executed first.
// Hello, 
// I will be printed after the pause
// World!
// undefined
```

For creating a generator function, we use `function*` syntax instead of just `function`. Since it is just a function, you can use it anywhere that a function can be used i.e inside objects, and class methods.

Inside the function body, we dont have a `return`. Instead, we have another keyword `yield` (Line 2). Its an operator with which a generator can pause itself. Every time a generator encounters a yield, it returns the value specified after it. In this case, Hello, is returned. However, we dont say returned in the context of generators. We say the the generator has `yielded` Hello, .

We can also `return` from a generator. However, return sets the `done` property to `true` after which the generator cannot generate any more values.

```js
function *  generatorFunc() {
  yield 'a';
  return 'b'; // Generator ends here.
  yield 'a'; // Will never be executed. 
}
```

In Line 3, we create the generator object. **It seems like we are invoking** the function generatorFunction. Indeed we are! The difference is that instead of returning any value, a generator function always returns a **generator object**. The generator object is an iterator. So you can use it in for-of loops or other functions accepting an iterable.

In Line 4, we call the `next()` method on the generatorObject. With this call, the generator begins executing. First, it console.log the `This will be executed first`. Then, it encounters a `yield` Hello, . The generator yields the value as an object `{ value: 'Hello, ', done: false }` and `suspends/pauses`. Now, it is waiting for the next invocation.

In Line 5, we call `next()` again. This time the generator wakes up and begin executing from where it left. The next line it finds is a console.log. It logs the string I will be printed after the pause. Another yield is encountered. The value is yielded as the object { value: 'World!', done: false }. We extract the value property and log it. The generator sleeps again.

In Line 6, we again invoke `next()`. This time there are no more lines to execute. Remember that every function implicitly returns undefined if no return statement is provided. Hence, the generator returns (instead of yielding) an object `{ value: undefined, done: true}`. The done is set to `true`. This signals the end of this generator. Now, it cant generate more values or resume again since there are no more statements to be executed.
